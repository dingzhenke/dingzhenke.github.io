(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{409:function(e,s,r){e.exports=r.p+"assets/img/base_server.cd03687d.png"},410:function(e,s,r){e.exports=r.p+"assets/img/read_msg.1ae9dead.png"},411:function(e,s,r){e.exports=r.p+"assets/img/read_msg2.317dbe49.png"},412:function(e,s,r){e.exports=r.p+"assets/img/send_msg.b6d89d7b.png"},413:function(e,s,r){e.exports=r.p+"assets/img/process.a0153f16.png"},433:function(e,s,r){"use strict";r.r(s);var a=r(2),t=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#基础非阻塞io管道设计"}},[e._v("基础非阻塞IO管道设计")])]),s("li",[s("a",{attrs:{href:"#读取消息块"}},[e._v("读取消息块")])]),s("li",[s("a",{attrs:{href:"#存储消息块"}},[e._v("存储消息块")])]),s("li",[s("a",{attrs:{href:"#写消息块"}},[e._v("写消息块")])]),s("li",[s("a",{attrs:{href:"#总结"}},[e._v("总结")])])])]),e._v("\n尽管你理解了Java NIO 非阻塞特性的工作原理（Selector，Channel，Buffer等），设计一个非阻塞的服务器仍然很艰难。非阻塞IO相对于阻塞IO来说包含着一些挑战。"),s("p"),e._v(" "),s("h2",{attrs:{id:"基础非阻塞io管道设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础非阻塞io管道设计"}},[e._v("#")]),e._v(" 基础非阻塞IO管道设计")]),e._v(" "),s("p",[e._v("一个非阻塞IO管道可以使用一个线程从多个channel中读取数据，这需要这些channel切换到非阻塞模式。为了避免检查那些没有数据可读的channel，我们使用Selector，示例图如下:")]),e._v(" "),s("p",[s("img",{attrs:{src:r(409),alt:"base server"}})]),e._v(" "),s("h2",{attrs:{id:"读取消息块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读取消息块"}},[e._v("#")]),e._v(" 读取消息块")]),e._v(" "),s("p",[e._v("当从channel中读取数据块时，我们并不知道该数据块是不是一个完整的消息。一个数据块可能包含一个消息碎片（不够一个完整的消息）、一个完整的消息或者超过一个消息，比如1.5个消息或者2.5个消息。就像下图所示：")]),e._v(" "),s("p",[s("img",{attrs:{src:r(410),alt:"read msg"}})]),e._v(" "),s("p",[e._v("在处理消息块时，存在两个挑战：")]),e._v(" "),s("ol",[s("li",[e._v("判断数据块中是否包含一个完整的消息（检测完整消息）")]),e._v(" "),s("li",[e._v("当消息剩余部分到来之前，如果处理已经到来的消息碎片（存储消息碎片）\n消息检测和碎片存储都是Message Reader的责任，为了避免混合来自多个channel的数据，我们对每个channel使用一个Message Reader，这个设计就像下图：")])]),e._v(" "),s("p",[s("img",{attrs:{src:r(411),alt:"read msg2"}})]),e._v(" "),s("h2",{attrs:{id:"存储消息块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储消息块"}},[e._v("#")]),e._v(" 存储消息块")]),e._v(" "),s("p",[e._v("很明显，消息块需要存储在某种buffer中，一个直接的方法就是每个Message Reader拥有一个buffer，但是这个buffer应该要多大？它应该能够存储被允许的最大的消息。但是如果直接将每个Message Reader的buffer大小设置为最大消息的大小，那么浪费量可能会很惊人，这时我们可以动态修改buffer的大小（拷贝或者追加）。")]),e._v(" "),s("h2",{attrs:{id:"写消息块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写消息块"}},[e._v("#")]),e._v(" 写消息块")]),e._v(" "),s("p",[e._v("在一个非阻塞IO管道中，写数据也面临着挑战，当你在一个非阻塞的channel上调用write()方法时，没办法保证一次性把所有需要写的数据都写完了，write()方法只是返回一共写了多少的字节的数据，所以你需要记录写了多少字节了，以便下次能够接着写直到把所有数据写完。")]),e._v(" "),s("p",[e._v("为了管理写消息到channel这个流程，我们创建一个Message Writer，就像Message Reader一样，每个channel需要一个Message Writer，每个Message Writer需要记录它当前写的消息中已经写了多少字节。")]),e._v(" "),s("p",[e._v("假如一时间多条消息到达一个Message Writer，而Writer一时间没办法将这些数据全部写入channel时，剩下的消息需要排队保存在Message Writer中，然后Writer尽快把这些消息写入channel中。")]),e._v(" "),s("p",[e._v("整个流程设计如下图：")]),e._v(" "),s("p",[s("img",{attrs:{src:r(412),alt:"send msg2"}})]),e._v(" "),s("p",[e._v("为了让Message Writer把之前发送了一部分的消息继续发送，Message Writer需要被经常调用。\n假设你拥有大量连接，那么就会有大量的Message Writer实例，假如需要检查100万个Message Writer实例的话，首先大部分实例可能没有待发送的消息，其次，并不是所有的channel都准备好了写数据，我们并不想浪费时间在这两种Writer上面。")]),e._v(" "),s("p",[e._v("为了检测一个channel是否准备好了写数据，我们可以将它注册到一个selector上，但是我们并不想把所有的channel注册到selector上，假设你拥有一百万条连接，这些连接都注册到了selector上，然而其中大部分都是空闲状态，那么，当你调用select()时，大部分的channel实例都处于写就绪的状态（因为他们大部分空闲），然后你必须所有这些连接的Writer，查看他们是否有数据需要写。")]),e._v(" "),s("p",[e._v("为了避免检查所有的Message Writer，我们采用一下方法，该方法一共分为两步：")]),e._v(" "),s("ol",[s("li",[e._v("当一个消息写入到Message Writer时，Message Writer将它的channel注册到Selector上，如果它还没有注册的话")]),e._v(" "),s("li",[e._v("当你的服务器有时间来检测selector，看看有哪些注册的channel进入写就绪状态。对于任何一个写就绪的channel，其对应的Writer会往里面写数据，当一个Writer写完了所有的数据到channel中，这个channel会从selector中解除注册。\n这个两步法可以确保只有那些真的有数据需要写入的channel才注册到selector上。")])]),e._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),s("p",[e._v("如你所见，一个非阻塞的服务器需要时不时的检查接收到的数据，看看是否有新的完整消息生成。同时，它也需要时不时的检查是否有数据需要发送，如果有，服务器需要检查是否有相关的channel处于写就绪状态。")]),e._v(" "),s("p",[e._v("总之，一个非阻塞的服务器最终需要经常处理三个管道：")]),e._v(" "),s("ol",[s("li",[e._v("读管道，检测打开的连接是否有新的数据到达")]),e._v(" "),s("li",[e._v("处理管道，处理所有接收到的完整消息")]),e._v(" "),s("li",[e._v("写管道，检测能否向任何打开的连接写入数据\n这三个管道在一个循环中重复执行，你也可以使用一定的方法优化这个执行过程。比如，如果没有消息在等待发送，你可以跳过写管道，又比如没有新的完整消息到达，你可以跳过消息处理管道。")])]),e._v(" "),s("p",[e._v("下图演示了完整的服务器循环：")]),e._v(" "),s("p",[s("img",{attrs:{src:r(413),alt:"process"}})])])}),[],!1,null,null,null);s.default=t.exports}}]);