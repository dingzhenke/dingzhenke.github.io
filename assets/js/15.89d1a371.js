(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{419:function(s,t,e){s.exports=e.p+"assets/img/skiplist.d348f680.png"},456:function(s,t,e){"use strict";e.r(t);var l=e(2),i=Object(l.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul")]),s._v("\n跳表是一个有多层索引的有序链表，由于大部分时候它的查询效率可以和平衡树媲美，同时实现比平衡树来得简单，所以Redis使用跳表作为有序集合键的底层实现之一。"),t("p"),s._v(" "),t("p",[s._v("redis中跳跃表的实现如下图：\n"),t("img",{attrs:{src:e(419),alt:"skiplist img"}})]),s._v(" "),t("p",[s._v("图中最左边是zskiplist，对应redis源码中的server.h/zskiplist结构体，代码如下：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("typedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\n    unsigned long length;\n    int level;\n} zskiplist;\n")])])]),t("p",[s._v("其中，header和tail分别指向表头，表尾，length为跳表内节点数，level为跳表内最大层级。")]),s._v(" "),t("p",[s._v("位于skiplist右边有四个zskiplistNode结构，源码如下：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("typedef struct zskiplistNode {\n    sds ele;\n    double score;\n    struct zskiplistNode *backward;\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned long span;\n    } level[];\n} zskiplistNode;\n")])])]),t("p",[s._v("可以看到他包含以下元素：")]),s._v(" "),t("ol",[t("li",[s._v("ele：结点存储的元素")]),s._v(" "),t("li",[s._v("score：结点存储的分值，结点按照分值从小到大排序。")]),s._v(" "),t("li",[s._v("backward：后退指针，方便从表尾向表头遍历")]),s._v(" "),t("li",[s._v("level数组：数组中每个元素代表一层，每层包含一个前进指针（forward）和到下一个节点的跨度（span）")])]),s._v(" "),t("p",[s._v("当我们需要查找对应分值元素时，我们先从头节点的最高层查起，当发现查找的节点在两个元素中间时，我们就去下层查找，依次类推，直到没有下一层。")])])}),[],!1,null,null,null);t.default=i.exports}}]);