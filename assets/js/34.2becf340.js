(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{450:function(e,n,t){"use strict";t.r(n);var a=t(2),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p"),n("div",{staticClass:"table-of-contents"},[n("ul",[n("li",[n("a",{attrs:{href:"#新建并初始化nioserversocketchannel"}},[e._v("新建并初始化NioServerSocketChannel")])]),n("li",[n("a",{attrs:{href:"#注册channel到selector"}},[e._v("注册channel到selector")])]),n("li",[n("a",{attrs:{href:"#将channel绑定到指定端口"}},[e._v("将channel绑定到指定端口")])]),n("li",[n("a",{attrs:{href:"#设置interestops为op-accept"}},[e._v("设置interestOps为OP_ACCEPT")])]),n("li",[n("a",{attrs:{href:"#调用selector的select系列方法"}},[e._v("调用selector的select系列方法")])])])]),n("p"),e._v(" "),n("p",[e._v("以下列代码为例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final EventLoopGroup bossGroup = new NioEventLoopGroup();\nfinal EventLoopGroup workGroup = new NioEventLoopGroup();\nfinal ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workGroup)\n        .channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(final SocketChannel ch) throws Exception {\n\n            }\n        });\nbootstrap.bind(5090).sync();\n")])])]),n("p",[e._v("断点调试跟踪最后一行bind方法，服务端初始化分为以下几步：")]),e._v(" "),n("ol",[n("li",[e._v("新建NioServerSocketChannel并初始化")]),e._v(" "),n("li",[e._v("注册channel到selector上")]),e._v(" "),n("li",[e._v("将channel 绑定到指定端口")]),e._v(" "),n("li",[e._v("修改SelectionKey的interestOps为OP_ACCEPT,开始监听连接事件")]),e._v(" "),n("li",[e._v("调用selector的select系列方法，查找就绪的channel，处理用户连接。")])]),e._v(" "),n("h2",{attrs:{id:"新建并初始化nioserversocketchannel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新建并初始化nioserversocketchannel"}},[e._v("#")]),e._v(" 新建并初始化NioServerSocketChannel")]),e._v(" "),n("p",[e._v("新建通过一行代码搞定")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final Channel channel = channelFactory().newChannel();\n")])])]),n("p",[e._v("新建之后，进行一些初始化操作，主要是设置一些选项，作为服务端，最主要的一步是添加一个ChannelInitializer到channel对应的pipeline中")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("p.addLast(new ChannelInitializer<Channel>() {\n    @Override\n    public void initChannel(final Channel ch) {\n        final ChannelPipeline pipeline = ch.pipeline();\n        ChannelHandler handler = config.handler();\n        if (handler != null) {\n            pipeline.addLast(handler);\n        }\n\n        ch.eventLoop().execute(new Runnable() {\n            @Override\n            public void run() {\n                pipeline.addLast(new ServerBootstrapAcceptor(\n                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n            }\n        });\n    }\n});\n")])])]),n("p",[e._v("该ChannelInitializer将一个ServerBootstrapAcceptor添加到pipeline中，该acceptor负责处理该server接收到的连接.")]),e._v(" "),n("h2",{attrs:{id:"注册channel到selector"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注册channel到selector"}},[e._v("#")]),e._v(" 注册channel到selector")]),e._v(" "),n("p",[e._v("注册是通过一下一行代码实现：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("ChannelFuture regFuture = config().group().register(channel);\n")])])]),n("p",[e._v("这里group方法返回一个EventLoopGroup，该对象持有一组EventLoop，当调用register方法时，根据其自身的选取算法选取一个EventLoop，然后将上一步初始化好了的channel注册到该EventLoop的selector上，至于为什么要注册，其原理可参见我的NIO相关知识。")]),e._v(" "),n("h2",{attrs:{id:"将channel绑定到指定端口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将channel绑定到指定端口"}},[e._v("#")]),e._v(" 将channel绑定到指定端口")]),e._v(" "),n("p",[e._v("将channel注册到selector之后，NioServerSocketChannel调用bind方法，通过层层委派，最终调用java nio channel的bind方法绑定指定端口地址。")]),e._v(" "),n("h2",{attrs:{id:"设置interestops为op-accept"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#设置interestops为op-accept"}},[e._v("#")]),e._v(" 设置interestOps为OP_ACCEPT")]),e._v(" "),n("p",[e._v("channel绑定端口后，触发channelActive事件，通过层层委派，最终调用到AbstractNioChannel的doBeginRead()方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Override\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    if (inputShutdown) {\n        return;\n    }\n\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\n    final int interestOps = selectionKey.interestOps();\n    if ((interestOps & readInterestOp) == 0) {\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n")])])]),n("p",[e._v("可以看到这里将selectionKey已有的interestOps与channel自己的readInterestOp进行或运算，设置为该key新的interestOps，然后我们可以从NioServerSocketChannel的构造方法中得知，该readInterestOp为OP_ACCEPT。至此，该channel已经准备好处理到来的连接")]),e._v(" "),n("h2",{attrs:{id:"调用selector的select系列方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#调用selector的select系列方法"}},[e._v("#")]),e._v(" 调用selector的select系列方法")]),e._v(" "),n("p",[e._v("当channel绑好端口、注册到对应的selector上且interestOp设置为OP_ACCEPT之后，我们就可以调用该selector的select系列方法查看有那些新的连接请求，该操作在NioEventLoop的run()方法中(run方法太长，截取部分代码，核心在strategy = select(curDeadlineNanos)这一行)，")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("try {\n    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());\n    switch (strategy) {\n        case SelectStrategy.CONTINUE:\n            continue;\n\n        case SelectStrategy.BUSY_WAIT:\n            // fall-through to SELECT since the busy-wait is not supported with NIO\n\n        case SelectStrategy.SELECT:\n            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n            if (curDeadlineNanos == -1L) {\n                curDeadlineNanos = NONE; // nothing on the calendar\n            }\n            nextWakeupNanos.set(curDeadlineNanos);\n            try {\n                if (!hasTasks()) {\n                    strategy = select(curDeadlineNanos);\n                }\n            } finally {\n                // This update is just to help block unnecessary selector wakeups\n                // so use of lazySet is ok (no race condition)\n                nextWakeupNanos.lazySet(AWAKE);\n            }\n            // fall through\n        default:\n        }\n    }catch (IOException e) {\n    // If we receive an IOException here its because the Selector is messed up. Let's rebuild\n    // the selector and retry. https://github.com/netty/netty/issues/8566\n    rebuildSelector0();\n    selectCnt = 0;\n    handleLoopException(e);\n    continue;\n}\n")])])]),n("p",[e._v("而run()方法又被SingleThreadEventExecutor的工作线程调用，所以要想能接收客户端连接，首先得让这个线程运行起来。工作线程是通过调用SingleThreadEventExecutor的startThread()方法启动的，该方法由execute()调用，所以当调用SingleThreadEventExecutor.execute()方法时，如果该工作线程没有启动，则其会自动启动，也就是说，当把任务交给该Executor时，会确保线程启动，代码如下:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Override\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException("task");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    if (inEventLoop) {\n        addTask(task);\n    } else {\n        startThread();//这里启动工作线程\n        addTask(task);\n        if (isShutdown() && removeTask(task)) {\n            reject();\n        }\n    }\n\n    if (!addTaskWakesUp && wakesUpForTask(task)) {\n        wakeup(inEventLoop);\n    }\n}\n')])])]),n("p",[e._v("至此，服务端已经准备好监听客户端的连接了")])])}),[],!1,null,null,null);n.default=r.exports}}]);