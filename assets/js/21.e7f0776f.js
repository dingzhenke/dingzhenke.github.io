(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{437:function(e,t,a){"use strict";a.r(t);var o=a(2),n=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#扫描和加载"}},[e._v("扫描和加载")]),t("ul",[t("li",[t("a",{attrs:{href:"#getextensionclasses"}},[e._v("getExtensionClasses")])]),t("li",[t("a",{attrs:{href:"#创建扩展类"}},[e._v("创建扩展类")])])])])])]),e._v("\n作为一个java程序员，dubbo的大名真的是如雷贯耳，今天就来看一看它的源码。\ndubbo中说得最多的就是SPI机制，SPI机制说到底就是根据不同配置加载不同扩展实现的机制，源码位于org.apache.dubbo.common.extension下，网上关于Dubbo SPI和JDK自带的SPI的区别的有太多，这里我就不再复述了，我们的目的是通过分析其源码，搞清楚以下几个问题：\n1、dubbo是怎么扫描和加载所需要的扩展的？\n2、dubbo是如何实现依赖注入的？"),t("p"),e._v(" "),t("p",[e._v("获取SPI扩展依赖于SpiExtensionFactory的getExtension方法，该方法调用的是ExtensionLoader的getAdaptiveExtension方法,最后调用createAdaptiveExtension()方法，createAdaptiveExtension()方法如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    private T createAdaptiveExtension() {\n        try {\n            return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n        } catch (Exception e) {\n            throw new IllegalStateException("Can\'t create adaptive extension " + type + ", cause: " + e.getMessage(), e);\n        }\n    }\n')])])]),t("p",[e._v("从这个方法，我们大概可以猜到，扫描和加载过程在getAdaptiveExtensionClass()方法中，而依赖注入过程在injectExtension()方法中。")]),e._v(" "),t("h2",{attrs:{id:"扫描和加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扫描和加载"}},[e._v("#")]),e._v(" 扫描和加载")]),e._v(" "),t("p",[e._v("我们先看第一步，扫描和加载，getAdaptiveExtensionClass()代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    private Class<?> getAdaptiveExtensionClass() {\n        getExtensionClasses();\n        if (cachedAdaptiveClass != null) {\n            return cachedAdaptiveClass;\n        }\n        return cachedAdaptiveClass = createAdaptiveExtensionClass();\n    }\n")])])]),t("p",[e._v("该方法做了两件事：\n1、通过getExtensionClasses获取所有的扩展类\n2、通过createAdaptiveExtensionClass创建一个扩展类的适配类")]),e._v(" "),t("h3",{attrs:{id:"getextensionclasses"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#getextensionclasses"}},[e._v("#")]),e._v(" getExtensionClasses")]),e._v(" "),t("p",[e._v("该方法最终会调用loadExtensionClasses()方法，用于加载所有扩展类，其代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    private Map<String, Class<?>> loadExtensionClasses() {\n        cacheDefaultExtensionName();\n\n        Map<String, Class<?>> extensionClasses = new HashMap<>();\n        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());\n        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace("org.apache", "com.alibaba"));\n        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());\n        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace("org.apache", "com.alibaba"));\n        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());\n        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace("org.apache", "com.alibaba"));\n        return extensionClasses;\n    }\n')])])]),t("p",[e._v("至此我们终于来到了实际进行扩展类扫描和加载的地方，在这里我们可以明白dubbo的扫描路径在哪，以及会扫描哪些类。")]),e._v(" "),t("h3",{attrs:{id:"创建扩展类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建扩展类"}},[e._v("#")]),e._v(" 创建扩展类")]),e._v(" "),t("p",[e._v("创建扩展类方法如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    private Class<?> createAdaptiveExtensionClass() {\n        String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();\n        ClassLoader classLoader = findClassLoader();\n        org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n        return compiler.compile(code, classLoader);\n    }\n")])])]),t("p",[e._v("该方法也是做了两件事：\n1、利用AdaptiveClassCodeGenerator工具类构建一个包含类源码的String\n2、递归调用ExtensionLoader加载一个编译器(Compiler)编译上一步生成的String为一个Class对象，这个Class对象就是最终的AdaptiveExtensionClass。")]),e._v(" "),t("p",[e._v("以下是一个Protocol的生成的适配类源码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package org.apache.dubbo.rpc;\n\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol {\n    public void destroy() {\n        throw new UnsupportedOperationException("The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!");\n    }\n\n    public int getDefaultPort() {\n        throw new UnsupportedOperationException("The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!");\n    }\n\n    public org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException("org.apache.dubbo.rpc.Invoker argument == null");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException("org.apache.dubbo.rpc.Invoker argument getUrl() == null");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol());\n        if (extName == null)\n            throw new IllegalStateException("Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (" + url.toString() + ") use keys([protocol])");\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        return extension.export(arg0);\n    }\n\n    public org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException {\n        if (arg1 == null) throw new IllegalArgumentException("url == null");\n        org.apache.dubbo.common.URL url = arg1;\n        String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol());\n        if (extName == null)\n            throw new IllegalStateException("Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (" + url.toString() + ") use keys([protocol])");\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        return extension.refer(arg0, arg1);\n    }\n}\n')])])]),t("p",[e._v("可以看到它实现了Protocol接口，在实现方法中根据Url里设置的extName调用对应的扩展实现类的对应方法。")])])}),[],!1,null,null,null);t.default=n.exports}}]);