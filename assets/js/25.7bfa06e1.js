(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{441:function(o,e,t){"use strict";t.r(e);var r=t(2),l=Object(r.a)({},(function(){var o=this,e=o._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul")]),o._v("\n因为model、proxy会被被其他模块依赖。所以把他们放在最前面分析"),e("p"),o._v(" "),e("h1",{attrs:{id:"model"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#model"}},[o._v("#")]),o._v(" model")]),o._v(" "),e("p",[o._v("model模块是dubbo中的实体域，它包含以下几个类：")]),o._v(" "),e("ul",[e("li",[o._v("ApplicationModel:对应一个应用实体，持有应用所有的ProviderModel和ConsumerModel")]),o._v(" "),e("li",[o._v("ProviderModel:对应一个服务提供者实体，持有多个ProviderMethodModel")]),o._v(" "),e("li",[o._v("ConsumerModel:对应一个服务消费者实体，持有多个ConsumerMethodModel")]),o._v(" "),e("li",[o._v("ProviderMethodModel:对应一个服务方法提供者实体，包含方法名，方法参数")]),o._v(" "),e("li",[o._v("ConsumerMethodModel:对应一个服务方法消费者实体，包含方法名，方法参数，返回值，可能会有该方法调用前后的钩子方法")])]),o._v(" "),e("h1",{attrs:{id:"proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[o._v("#")]),o._v(" proxy")]),o._v(" "),e("p",[o._v("顾名思义，proxy模块功能是动态代理。将指定接口的方法动态代理到Invoker去执行")])])}),[],!1,null,null,null);e.default=l.exports}}]);