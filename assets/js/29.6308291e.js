(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{457:function(e,r,t){"use strict";t.r(r);var n=t(2),s=Object(n.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#dorefer"}},[e._v("doRefer")])]),r("li",[r("a",{attrs:{href:"#创建代理"}},[e._v("创建代理")])])])]),e._v("\n本节我们来看看，Dubbo是如何实现refer的。"),r("p"),e._v(" "),r("p",[e._v("dubbo中服务的refer源自ReferenceConfig的refer方法，其源码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('    public synchronized T get() {\n        checkAndUpdateSubConfigs();\n\n        if (destroyed) {\n            throw new IllegalStateException("The invoker of ReferenceConfig(" + url + ") has already destroyed!");\n        }\n        if (ref == null) {\n            init();\n        }\n        return ref;\n    }\n')])])]),r("p",[e._v("和export一样，配置的整合我们就不看了，主要看init方法。init方法内容众多，大部分都是配置的处理，我用就省略掉，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    private void init() {\n        //配置的整合\n        ......\n\n        ref = createProxy(map);\n        String serviceKey = URL.buildKey(interfaceName, group, version);\n        ApplicationModel.initConsumerModel(serviceKey, buildConsumerModel(serviceKey, attributes));\n        initialized = true;\n    }\n")])])]),r("p",[e._v("这里核心是createProxy，我们深入地看看它：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('    private T createProxy(Map<String, String> map) {\n        if (shouldJvmRefer(map)) {\n            URL url = new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map);\n            invoker = REF_PROTOCOL.refer(interfaceClass, url);\n            if (logger.isInfoEnabled()) {\n                logger.info("Using injvm service " + interfaceClass.getName());\n            }\n        } else {\n            // assemble URL \n            ......\n            if (urls.size() == 1) {\n                invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));\n            } else {\n                List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n                URL registryURL = null;\n                for (URL url : urls) {\n                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));\n                    if (REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                        registryURL = url; // use last registry url\n                    }\n                }\n                if (registryURL != null) { // registry url is available\n                    // use RegistryAwareCluster only when register\'s CLUSTER is available\n                    URL u = registryURL.addParameter(CLUSTER_KEY, RegistryAwareCluster.NAME);\n                    // The invoker wrap relation would be: RegistryAwareClusterInvoker(StaticDirectory) -> FailoverClusterInvoker(RegistryDirectory, will execute route) -> Invoker\n                    invoker = CLUSTER.join(new StaticDirectory(u, invokers));\n                } else { // not a registry url, must be direct invoke.\n                    invoker = CLUSTER.join(new StaticDirectory(invokers));\n                }\n            }\n        }\n        ......\n        // create service proxy\n        return (T) PROXY_FACTORY.getProxy(invoker);\n    }\n')])])]),r("p",[e._v("可以看到，这里和export类似，主要做了以下几件事情：\n1、如果配置了本地refer，则refer本地服务\n2、如果没有，则refer远程服务。\n3、最后再调用PROXY_FACTORY创建代理")]),e._v(" "),r("h2",{attrs:{id:"dorefer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dorefer"}},[e._v("#")]),e._v(" doRefer")]),e._v(" "),r("p",[e._v("refer本地服务比较简单，读者有兴趣可以自己研究，这里只是分析下refer到远程，本次分析使用nacos作为注册中心，且注册中心没有集群，所以会通过REF_PROTOCOL.refer(interfaceClass, urls.get(0))来创建invoker，结合dubbo SPI方式最后调用RegistryProtocol的doRefer方法，方法如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('    private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {\n        RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);\n        directory.setRegistry(registry);\n        directory.setProtocol(protocol);\n        // all attributes of REFER_KEY\n        Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());\n        URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);\n        if (!ANY_VALUE.equals(url.getServiceInterface()) && url.getParameter(REGISTER_KEY, true)) {\n            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));\n            registry.register(directory.getRegisteredConsumerUrl());\n        }\n        directory.buildRouterChain(subscribeUrl);\n        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,\n                PROVIDERS_CATEGORY + "," + CONFIGURATORS_CATEGORY + "," + ROUTERS_CATEGORY));\n\n        Invoker invoker = cluster.join(directory);\n        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n        return invoker;\n    }\n')])])]),r("p",[e._v("我们来分析以下这个方法，它首先新建并初始化一个RegistryDirectory，然后在注册中心中注册该服务，再设置router、订阅provider，最后创建Invoker。最后的创建Invoker是使用cluster.join方法创建，该方法通过dubbo SPI获得一个包裹FailoverCluster的MockClusterWrapper，然后调用其join方法，构建了一个包裹FailoverClusterInvoker的MockClusterInvoker。MockClusterInvoker主要是处理mock，而FailoverClusterInvoker主要是处理失败重试机制。")]),e._v(" "),r("h2",{attrs:{id:"创建代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建代理"}},[e._v("#")]),e._v(" 创建代理")]),e._v(" "),r("p",[e._v("通过上面的分析，我们已经知道了返回的Invoker是一个MockClusterInvoker了，接下来是创建代理，这里还是使用Dubbo的SPI机制，最后调用JavassistProxyFactory.createProxy方法:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n")])])]),r("p",[e._v("这里创建一个代理，该代理的作用是将需要的服务方法调用交给InvokerInvocationHandler代理。")]),e._v(" "),r("p",[e._v("至此Dubbo的服务refer基本分析完毕")])])}),[],!1,null,null,null);r.default=s.exports}}]);