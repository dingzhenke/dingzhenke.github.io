(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{467:function(t,e,n){"use strict";n.r(e);var a=n(2),i=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul")]),t._v("\n通过对BeanFactory的分析，我们已经大致了解了SpringBoot是如何初始并且实例化Bean的，但是初始化时，BeanDefinition又从哪里来呢？沿着SpringApplication的run方法继续往下走，我们来到了今天我们要讲的load方法，SpringBoot正是通过该方法加载BeanDefinition.该方法实际上是调用BeanDefinitionLoader的load方法"),e("p"),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('    private int load(Object source) {\n\t\tAssert.notNull(source, "Source must not be null");\n\t\tif (source instanceof Class<?>) {\n\t\t\treturn load((Class<?>) source);\n\t\t}\n\t\tif (source instanceof Resource) {\n\t\t\treturn load((Resource) source);\n\t\t}\n\t\tif (source instanceof Package) {\n\t\t\treturn load((Package) source);\n\t\t}\n\t\tif (source instanceof CharSequence) {\n\t\t\treturn load((CharSequence) source);\n\t\t}\n\t\tthrow new IllegalArgumentException("Invalid source type " + source.getClass());\n\t}\n')])])]),e("p",[t._v("为了简单起见，我们先研究它的load(Class<?> claz)方法，BeanDefinitionLoader实际上是采用了facade模式，会根据不同的参数，调用不同的方法加载BeanDefinition，当传入class参数时，实际上是调用AnnotatedBeanDefinitionReader的register方法，最终调用其doRegisterBean方法:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\tprivate <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,\n\t\t\t@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,\n\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) {\n\n\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);\n\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\treturn;\n\t\t}\n\n\t\tabd.setInstanceSupplier(supplier);\n\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);\n\t\tabd.setScope(scopeMetadata.getScopeName());\n\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);\n\t\tif (qualifiers != null) {\n\t\t\tfor (Class<? extends Annotation> qualifier : qualifiers) {\n\t\t\t\tif (Primary.class == qualifier) {\n\t\t\t\t\tabd.setPrimary(true);\n\t\t\t\t}\n\t\t\t\telse if (Lazy.class == qualifier) {\n\t\t\t\t\tabd.setLazyInit(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (customizers != null) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(abd);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);\n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);\n\t}\n")])])]),e("p",[t._v("该方法大概步骤如下：\n1、新建AnnotatedGenericBeanDefinition,提供读取该Class的注释的接口\n2、判断是否要忽略该Bean，以及判断Bean的SCOPE\n3、根据Class的注释，设置Lazy、Primary、DependsOn、Role、Description等注释的值\n4、如果有传入BeanDefinitionCustomizer，则执行其customize方法对BeanDefinition进行一些操作。\n5、进行一些SCOPE的自定义操作\n6、在ApplicationContext中注册该BeanDefinition和alias")]),t._v(" "),e("p",[t._v("到此load(Class claz)基本分析结束，后面可以再返回来详细分析其中某一个方面，现在让我们继续往前走。")])])}),[],!1,null,null,null);e.default=i.exports}}]);