(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{462:function(t,n,e){"use strict";e.r(n);var r=e(2),o=Object(r.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p"),n("div",{staticClass:"table-of-contents"},[n("ul",[n("li",[n("a",{attrs:{href:"#总述"}},[t._v("总述")])]),n("li",[n("a",{attrs:{href:"#分析方法思路"}},[t._v("分析方法思路")])])])]),n("p"),t._v(" "),n("h2",{attrs:{id:"总述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总述"}},[t._v("#")]),t._v(" 总述")]),t._v(" "),n("p",[t._v("今天开一个新坑，讲讲springboot源码，其实以前也尝试着分析过一次，不过后面陷入了细节，而且没有记录，慢慢就忘记了，所以今天开始重新分析一遍，然后记录下来。")]),t._v(" "),n("h2",{attrs:{id:"分析方法思路"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分析方法思路"}},[t._v("#")]),t._v(" 分析方法思路")]),t._v(" "),n("p",[t._v("上次分析了netty的源码，感觉和springboot的源码比起来，真是小巫见大巫，可能是因为springboot站在spring的肩膀上，导致复杂度要高不少，概念繁多。现在的思路是：\n1、先大致过一遍springboot的启动过程\n2、一个一个分析启动过程中遇到的一些概念\n3、最后看能不能把这些概念串起来，给出一个全貌")]),t._v(" "),n("p",[t._v("由于springboot是站在spring的肩膀上，所以其中会有很多spring的源码分析。好吧，闲话少续，咋们看代码。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public ConfigurableApplicationContext run(String... args) {\n\t\tStopWatch stopWatch = new StopWatch();\n\t\tstopWatch.start();\n\t\tConfigurableApplicationContext context = null;\n\t\tCollection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n\t\tconfigureHeadlessProperty();\n\t\tSpringApplicationRunListeners listeners = getRunListeners(args);    \n\t\tlisteners.starting();\n\t\ttry {\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n\t\t\tConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n\t\t\tconfigureIgnoreBeanInfo(environment);\n\t\t\tBanner printedBanner = printBanner(environment);\n\t\t\tcontext = createApplicationContext();\n\t\t\texceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n\t\t\t\t\tnew Class[] { ConfigurableApplicationContext.class }, context);\n\t\t\tprepareContext(context, environment, listeners, applicationArguments, printedBanner);\n\t\t\trefreshContext(context);\n\t\t\tafterRefresh(context, applicationArguments);\n\t\t\tstopWatch.stop();\n\t\t\tif (this.logStartupInfo) {\n\t\t\t\tnew StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n\t\t\t}\n\t\t\tlisteners.started(context);\n\t\t\tcallRunners(context, applicationArguments);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleRunFailure(context, ex, exceptionReporters, listeners);\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\n\t\ttry {\n\t\t\tlisteners.running(context);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleRunFailure(context, ex, exceptionReporters, null);\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t\treturn context;\n\t}\n")])])]),n("p",[t._v("沿着springboot的启动入口SpringApplication.run方法，深入，一路上我们会遇到以下的概念：\n1、SpringApplicationRunListener\n2、Environment\n3、ConfigurableApplicationContext\n3.1 BeanFactory\n3.1.1 BeanExpressionResolver\n3.1.2 ResourceEditorRegister\n3.1.3 BeanPostProcessor\n3.1.4 ignoreDependnceInterface\n3.1.5 LoadTimeWeaver\n3.1.6 BeanFactoryPostProcessor\n3.1.7 BeanDefinitionRegistryPostProcessor\n3.1.8 Order\n3.1.9 MergeBeanDefinitionPostProcssor\n3.2 ResourceLoader\n4、ApplicationContextInitializer\n5、MessageSource\n以上只是粗略的列一下，我们采用分治的思想，沿着run方法，一口一口啃SpringBoot这块硬骨头")])])}),[],!1,null,null,null);n.default=o.exports}}]);