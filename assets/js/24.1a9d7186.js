(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{440:function(e,r,t){"use strict";t.r(r);var n=t(2),a=Object(n.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#getclients-url"}},[e._v("getClients(url)")])]),r("li",[r("a",{attrs:{href:"#openserver-url-url"}},[e._v("openServer(Url url)")])])])]),e._v("\nprotocol是rpc模块中最重要的部分，本节我们就来分析一下它。首先我们通过AbstractProtocol看Protocol接口，接口如下，省略了注释和注解："),r("p"),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public interface Protocol {\n    int getDefaultPort();\n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n    void destroy();\n}\n")])])]),r("p",[e._v("从接口中我们得知，protocol的最主要的功能就是导出服务（export）以及生成远程服务的钩子（refer）。")]),e._v(" "),r("h1",{attrs:{id:"refer-class-type-url-url"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#refer-class-type-url-url"}},[e._v("#")]),e._v(" refer(Class"),r("T",[e._v(" type, URL url)")])],1),e._v(" "),r("p",[e._v("我们将目光转回AbstractProtocol，发现它实现了refer方法，该方法如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n        return new AsyncToSyncInvoker<>(protocolBindingRefer(type, url));\n    }\n")])])]),r("p",[e._v("这里调用了一个由子类实现的方法protocolBindingRefer，由于dubbo推荐使用dubbo协议，所以我只分析DubboProtocol实现，其他的实现如果读者有兴趣，可以自行研究。DubboProtocol的实现如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    public <T> Invoker<T> protocolBindingRefer(Class<T> serviceType, URL url) throws RpcException {\n        optimizeSerialization(url);\n\n        // create rpc invoker.\n        DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);\n        invokers.add(invoker);\n\n        return invoker;\n    }\n")])])]),r("p",[e._v("该方法主要做了以下两件事：\n1、调用getClients方法获取ExchangeClients\n2、利用第一步创建的ExchangeClients构建一个DubboInvoker对象\n第二步比较简单，只是构建一个DubboInvoker对象，我们着重分析一下getClients方法。")]),e._v(" "),r("h2",{attrs:{id:"getclients-url"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#getclients-url"}},[e._v("#")]),e._v(" getClients(url)")]),e._v(" "),r("p",[e._v("该方法通过各种判断，最后调用了Exchangers.connect方法，该方法根据配置调用对应的Exchanger的connect方法，Dubbo里默认的是HeaderExchanger,它的connect方法如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n        return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);\n}\n")])])]),r("p",[e._v("可以看到它只是构建了一个HeaderExchangeClient并返回。我们就来看看它是怎么构建的。从上面的代码中，我们可以看到，HeaderExchangeClient实际上是持有了一个Client，该Client由Transporters.connect方法返回，该方法也是根据配置调用对应的Transporter的connect方法，dubbo默认是netty，那我们继续来看NettyTransporter的connect方法，方法如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    public Client connect(URL url, ChannelHandler listener) throws RemotingException {\n        return new NettyClient(url, listener);\n    }\n")])])]),r("p",[e._v("可以看到，这里也只是返回一个NettyClient对象。我们追踪NettyClient构造函数到AbstractClient中，看AbstractClient的构造方法：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    public AbstractClient(URL url, ChannelHandler handler) throws RemotingException {\n        ......\n        doOpen();\n        ......\n        connect();\n        ......\n        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(DataStore.class)\n                .getDefaultExtension().get(CONSUMER_SIDE, Integer.toString(url.getPort()));\n        ExtensionLoader.getExtensionLoader(DataStore.class)\n                .getDefaultExtension().remove(CONSUMER_SIDE, Integer.toString(url.getPort()));\n    }\n")])])]),r("p",[e._v("我省略了一些模板代码，只留下核心代码，这样看起来比较清晰，可以看到它只是先doOpen然后再connect，connect实际只是调用doConnect。在NettyClient中，doOpen只是新建一个netty客户端（bootStrap），而doConnect只是连接远程服务器，这里就不往下分析了，感兴趣的可以看我之前分析NIO的文章。")]),e._v(" "),r("p",[e._v("至此，getClients就已经分析完毕了。总结一下，一个Client的建立大致经过Exchanger--\x3eHeaderExchangeClient--\x3eTransporter->NettyClient--\x3enetty库，这样一个过程。")]),e._v(" "),r("h1",{attrs:{id:"export-invoker-invoker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#export-invoker-invoker"}},[e._v("#")]),e._v(" export(Invoker"),r("T",[e._v(" invoker)")])],1),e._v(" "),r("p",[e._v("和上面一样，我只是分析Dubbo协议实现，DubboProtocol的Export方法如下:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        URL url = invoker.getUrl();\n\n        // export service.\n        String key = serviceKey(url);\n        DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n        exporterMap.put(key, exporter);\n\n        //export an stub service for dispatching event\n        Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);\n        Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false);\n        if (isStubSupportEvent && !isCallbackservice) {\n            String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);\n            if (stubServiceMethods == null || stubServiceMethods.length() == 0) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(new IllegalStateException("consumer [" + url.getParameter(INTERFACE_KEY) +\n                            "], has set stubproxy support event ,but no stub methods founded."));\n                }\n\n            } else {\n                stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n            }\n        }\n\n        openServer(url);\n        optimizeSerialization(url);\n\n        return exporter;\n    }\n')])])]),r("p",[e._v("该方法主要做了以下几件事:\n1、构建一个DubboExporter并放在ExporterMap中\n2、处理存根方法\n3、开启服务\n前面两个都比较简单，比较容易看懂，所以我只是分析以下第三步。")]),e._v(" "),r("h2",{attrs:{id:"openserver-url-url"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#openserver-url-url"}},[e._v("#")]),e._v(" openServer(Url url)")]),e._v(" "),r("p",[e._v("openServer里采用double-check，然后调用createServer方法，createServer方法如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    private ExchangeServer createServer(URL url) {\n        url = URLBuilder.from(url)\n                // send readonly event when server closes, it's enabled by default\n                .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())\n                // enable heartbeat by default\n                .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))\n                .addParameter(CODEC_KEY, DubboCodec.NAME)\n                .build();\n        String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);\n        ......\n        ExchangeServer server;\n        ......\n        server = Exchangers.bind(url, requestHandler);\n        ......\n        return server;\n    }\n")])])]),r("p",[e._v("这里我们可以看到它实际是调用Exchangers.bind方法，我们可以发现这个和前面讲解的refer方法类似，那么就不复述了，只说一下结论。通过追踪代码我们发现，一个server的建立，大概路线为\nExchanger--\x3eHeaderExchangeServer--\x3eTransporter--\x3eNettyServer--\x3enetty库。")]),e._v(" "),r("p",[e._v("到此，DubboProtocol基本分析完毕了,protocol模块也暂时分析到这里，下章我们分析下一个模块--cluster")])])}),[],!1,null,null,null);r.default=a.exports}}]);