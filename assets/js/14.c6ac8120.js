(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{418:function(n,e,a){n.exports=a.p+"assets/img/pipeline.aafce198.png"},452:function(n,e,a){"use strict";a.r(e);var l=a(2),t=Object(l.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#为什么要讲channelpipeline"}},[n._v("为什么要讲ChannelPipeline")])]),e("li",[e("a",{attrs:{href:"#channelpipeline-是什么"}},[n._v("ChannelPipeline 是什么")])]),e("li",[e("a",{attrs:{href:"#如何创建一个管道"}},[n._v("如何创建一个管道")])]),e("li",[e("a",{attrs:{href:"#事件如何在管道中流动"}},[n._v("事件如何在管道中流动")])]),e("li",[e("a",{attrs:{href:"#传递事件给下一个handler"}},[n._v("传递事件给下一个handler")])]),e("li",[e("a",{attrs:{href:"#构建一条管道"}},[n._v("构建一条管道")])]),e("li",[e("a",{attrs:{href:"#线程安全"}},[n._v("线程安全")])])])]),e("p"),n._v(" "),e("h2",{attrs:{id:"为什么要讲channelpipeline"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要讲channelpipeline"}},[n._v("#")]),n._v(" 为什么要讲ChannelPipeline")]),n._v(" "),e("p",[n._v("上节讲到服务器如何处理到来的连接,进到了最终是调用了pipeline.fireChannelRead,要弄清楚里面到底发生了什么，就不得不了解一下什么是ChannelPipeline。关于ChannelPipeline，个人觉得源码的注释已经讲得很清楚了，所以这里只是翻译一下，有兴趣的可以去看源码注释。")]),n._v(" "),e("h2",{attrs:{id:"channelpipeline-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelpipeline-是什么"}},[n._v("#")]),n._v(" ChannelPipeline 是什么")]),n._v(" "),e("p",[n._v("ChannelPipeline是一系列处理、拦截channel的inbound事件和outbound操作的ChannelHandler。ChannelPipeline实现了一种高级形式的拦截过滤模式（Intercepting Filter pattern）。让用户可以完全控制事件的处理方式以及ChannelHandler间的交互方式。")]),n._v(" "),e("h2",{attrs:{id:"如何创建一个管道"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何创建一个管道"}},[n._v("#")]),n._v(" 如何创建一个管道")]),n._v(" "),e("p",[n._v("每个channel都有一个自己的管道，该管道在channel创建的的自动创建")]),n._v(" "),e("h2",{attrs:{id:"事件如何在管道中流动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件如何在管道中流动"}},[n._v("#")]),n._v(" 事件如何在管道中流动")]),n._v(" "),e("p",[n._v("下图展示了事件在ChannelPipeline的ChannelHandlers中典型的处理方式，一个IO事件总是会被一个ChannelInboundHandler或者ChannelOutboundHandler处理，然后通过ChannelHandlerContext中定义的传递方法传递给它最近的一个handler，比如ChannelHandlerContext#fireChannelRead(Object)和ChannelHandlerContext#write(Object)方法。"),e("br"),n._v(" "),e("img",{attrs:{src:a(418),alt:"I/O Request via Channel or ChannelHandlerContext"}})]),n._v(" "),e("p",[n._v("一个inbound事件被inbound处理实例们按照自底向上的顺序处理，就像上图左边所示。一个inbound处理实例通常处理来自图中底部的I/O线程的inbound数据，而inbound数据一般是通过SocketChannel.read(ByteBuffer)方法读取的来自远端的数据，当数据已经通过了最上面的inbound处理实例，数据将被默默丢弃或者打印出来。")]),n._v(" "),e("p",[n._v("一个outbound事件被outbound处理实例们按照自上而下的顺序处理，就像上图右边所示。一个outbound处理实例通常生成或者传输outbound流量，比如写请求。如果outbound事件通过了最下面的outbound处理实例，它将被该channel对应的I/O线程处理。I/O线程通常执行实际的输出操作，比如SocketChannel.write(ByteBuffer)")]),n._v(" "),e("p",[n._v("举个例子，假如我们创建了以下pipeline:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('ChannelPipeline} p = ...;\np.addLast("1", new InboundHandlerA());\np.addLast("2", new InboundHandlerB());\np.addLast("3", new OutboundHandlerA());\np.addLast("4", new OutboundHandlerB());\np.addLast("5", new InboundOutboundHandlerX());\n')])])]),e("p",[n._v("在上面的例子中，名字以Inbound开头的类表示它是一个inbound 处理类。名字以Outbound开头的类表示它是一个outbound 处理类。")]),n._v(" "),e("p",[n._v("在给定例子的配置中，当事件为inbound类型时，处理类执行顺序为1，2，3，4，5，当事件为outbound类型时，顺序为5，4，3，2，1.在这个规则基础上，跳过指定的handlers来减少栈深度：")]),n._v(" "),e("ol",[e("li",[n._v("因为3，4并没有实现ChannelInboundHandler，所以当事件类型为inbound时，实际执行顺序为：1，2和5.")]),n._v(" "),e("li",[n._v("1和2并没有继承ChannelOutboundHandler，所以当事件类型为outbound时，实际执行顺序为5，4和3.")]),n._v(" "),e("li",[n._v("如果5继承了ChannelInboundHandler和ChannelOutboundHandler，那么inbound事件和outbound事件的执行顺序分别为125和543.")])]),n._v(" "),e("h2",{attrs:{id:"传递事件给下一个handler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传递事件给下一个handler"}},[n._v("#")]),n._v(" 传递事件给下一个handler")]),n._v(" "),e("p",[n._v("你可以已经注意到在前面的图中，一个handler必须调用ChannelHandlerContext里的事件传播方法来将事件传递给下一个handler，这些方法包括：")]),n._v(" "),e("ol",[e("li",[n._v("Inbound事件传播方法:")])]),n._v(" "),e("ul",[e("li",[n._v("ChannelHandlerContext.fireChannelRegistered()")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireChannelActive()")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireChannelRead(Object)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireChannelReadComplete()")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireExceptionCaught(Throwable)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireUserEventTriggered(Object)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireChannelWritabilityChanged()")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireChannelInactive()")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.fireChannelUnregistered()")])]),n._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[n._v("Outbound事件传播方法:")])]),n._v(" "),e("ul",[e("li",[n._v("ChannelHandlerContext.bind(SocketAddress, ChannelPromise)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.write(Object, ChannelPromise)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.flush()")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.read()")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.disconnect(ChannelPromise)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.close(ChannelPromise)")]),n._v(" "),e("li",[n._v("ChannelHandlerContext.deregister(ChannelPromise)\n下面这个例子展示事件是如何传递的：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('public class MyInboundHandler extends ChannelInboundHandlerAdapter {\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        System.out.println("Connected!");\n        ctx.fireChannelActive();\n    }\n}\n \npublic class MyOutboundHandler extends ChannelOutboundHandlerAdapter {\n    @Override\n    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n         System.out.println("Closing ..");\n         ctx.close(promise);\n    }\n}\n')])])]),e("h2",{attrs:{id:"构建一条管道"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建一条管道"}},[n._v("#")]),n._v(" 构建一条管道")]),n._v(" "),e("p",[n._v("一个用户可能会在一个管道中使用一个或者多个ChannelHanlder接收I/O事件（比如读）和请求I/O操作（比如写和关闭）。举个例子，一个典型的服务器将在每个channel的管道里使用以下handler，当然实际情况取决于协议和业务逻辑的复杂度和特性。")]),n._v(" "),e("ol",[e("li",[n._v("协议解码器 - 将二进制数据转化为java对象")]),n._v(" "),e("li",[n._v("协议编码器 - 将java对象转为二进制数据")]),n._v(" "),e("li",[n._v("业务逻辑处理器 - 执行实际的业务逻辑（比如数据库访问）\n就像下面这个例子：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(' static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);\n ...\n\n ChannelPipeline pipeline = ch.pipeline();\n\n pipeline.addLast("decoder", new MyProtocolDecoder());\n pipeline.addLast("encoder", new MyProtocolEncoder());\n\n //将MyBusinessLogicHandler的事件处理方法放到非I/O线程处理，防止耗时任务阻塞I/O线程，如果你的业///务逻辑是全异步的或者耗时很短，则不需另外指定线程\n pipeline.addLast(group, "handler", new MyBusinessLogicHandler());\n')])])]),e("h2",{attrs:{id:"线程安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[n._v("#")]),n._v(" 线程安全")]),n._v(" "),e("p",[n._v("一个ChannelHandler可以在任意时候移除或者添加到ChannelPipeline中，因为ChannelPipeline是线程安全的，比如你可以在交换敏感信息时添加一个加密handler，然后在交换结束后移除该handler。")])])}),[],!1,null,null,null);e.default=t.exports}}]);