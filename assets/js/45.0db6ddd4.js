(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{466:function(t,n,e){"use strict";e.r(n);var a=e(2),s=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p"),n("div",{staticClass:"table-of-contents"},[n("ul",[n("li",[n("a",{attrs:{href:"#解析"}},[t._v("解析")])]),n("li",[n("a",{attrs:{href:"#读取"}},[t._v("读取")])])])]),t._v("\n开发过程中，你可能会好奇，为什么有些类加上@Configuration注释就会被SpringBoot加载并进行相关操作，比如将类中有@Bean注解的方法的返回值加入容器管理中，本章我们就来看看这背后的逻辑。"),n("p"),t._v(" "),n("p",[t._v("可以处理注解的ApplicationContext（有AnnotationConfig前缀）都会持有一个AnnotatedBeanDefinitionReader对象，该Reader初始化时会往ApplicationContext的BeanFactory中添加一个ConfigurationClassPostProcessor的Bean。当SpringApplication启动后进入刷新阶段时(onRefresh)会调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法，而ConfigurationClassPostProcessor就是其中之一。ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry方法很简单，基本是直接调用其processConfigBeanDefinitions方法。下面我们就来看看该方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('    public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n\t\tString[] candidateNames = registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n\t\t\tif (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug("Bean definition has already been processed as a configuration class: " + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tconfigCandidates.sort((bd1, bd2) -> {\n\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr = null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr = (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(\n\t\t\t\t\t\tAnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator != null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n\t\t\t\t\tthis.importBeanNameGenerator = generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader == null) {\n\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n\t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n\t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames = newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\'ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}\n')])])]),n("p",[t._v("代码有点多，不过该方法大致流程如下：\n1、过滤出BeanFactory中被@Configuraiton注解的Bean的BeanDefinition。并排序\n2、接下来是个do-while循环")]),t._v(" "),n("ul",[n("li",[t._v("使用ConfigurationClassParser解析所有的过滤后的BeanDefinition")]),t._v(" "),n("li",[t._v("使用ConfigurationClassBeanDefinitionReader读取上一步解析生成的ConfigurationClass引入的BeanDefinition")]),t._v(" "),n("li",[t._v("判断是否有引入新的Configuration注解的BeanDefinition,如果有则调用第一步继续解析，直到没有引入新的带Configuration注解的BeanDefinition")])]),t._v(" "),n("p",[t._v("//TODO\n路线图\n下面我们分别来讲解这两个步骤")]),t._v(" "),n("h2",{attrs:{id:"解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[t._v("#")]),t._v(" 解析")]),t._v(" "),n("p",[t._v("解析操作是由ConfigurationClassParser类完成，核心代码在doProcessConfigurationClass方法中")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t"]. Reason: Environment must implement ConfigurableEnvironment");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray("locations");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith("java") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}\n')])])]),n("p",[t._v("该方法流程如下：")]),t._v(" "),n("ul",[n("li",[t._v("processMemberClass：递归处理内部类")]),t._v(" "),n("li",[t._v("processPropertySource：处理@PropertySource引入的属性")]),t._v(" "),n("li",[t._v("componentScan：处理@ComponentScan注解，递归处理扫描到的BeanDefinition")]),t._v(" "),n("li",[t._v("processImports：递归处理@Import注解引入的Bean")]),t._v(" "),n("li",[t._v("ImportResource：处理@ImportResouce")]),t._v(" "),n("li",[t._v("BeanMethod：获取类中的BeanMethod")]),t._v(" "),n("li",[t._v("Default Method of Interfaces：处理所有父类接口中默认方法")]),t._v(" "),n("li",[t._v("Super class：递归处理父类")])]),t._v(" "),n("h2",{attrs:{id:"读取"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#读取"}},[t._v("#")]),t._v(" 读取")]),t._v(" "),n("p",[t._v("读取操作是由ConfigurationClassBeanDefinitionReader完成，主要是在loadBeanDefinitionsForConfigurationClass中，代码如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\tprivate void loadBeanDefinitionsForConfigurationClass(\n\t\t\tConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {\n\n\t\tif (trackedConditionEvaluator.shouldSkip(configClass)) {\n\t\t\tString beanName = configClass.getBeanName();\n\t\t\tif (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {\n\t\t\t\tthis.registry.removeBeanDefinition(beanName);\n\t\t\t}\n\t\t\tthis.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());\n\t\t\treturn;\n\t\t}\n\n\t\tif (configClass.isImported()) {\n\t\t\tregisterBeanDefinitionForImportedConfigurationClass(configClass);\n\t\t}\n\t\tfor (BeanMethod beanMethod : configClass.getBeanMethods()) {\n\t\t\tloadBeanDefinitionsForBeanMethod(beanMethod);\n\t\t}\n\n\t\tloadBeanDefinitionsFromImportedResources(configClass.getImportedResources());\n\t\tloadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());\n\t}\n")])])]),n("p",[t._v("该方法比较清晰，大体流程如下：")]),t._v(" "),n("ul",[n("li",[t._v("判断是否要导入ConfigurationClass自身BeanDefinition")]),t._v(" "),n("li",[t._v("导入BeanMethod所生成的BeanDefinition")]),t._v(" "),n("li",[t._v("导入ImportResource引入的BeanDefinition")]),t._v(" "),n("li",[t._v("导入importBeanDefinitionRegistrars引入的BeanDefinition")])]),t._v(" "),n("p",[t._v("至此，ConfigurationClassPostProcessor分析完毕，我们也可以解释一开始那个问题，就是说@Bean注解是如何起作用的")])])}),[],!1,null,null,null);n.default=s.exports}}]);