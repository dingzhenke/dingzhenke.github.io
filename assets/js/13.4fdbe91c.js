(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{417:function(r,t,n){r.exports=n.p+"assets/img/objecthead.ad7f708e.png"},436:function(r,t,n){"use strict";n.r(t);var a=n(2),o=Object(a.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul")]),t("p"),r._v(" "),t("p",[r._v("并发的三性： 原子性、可见性和有序性。synchronized提供原子性（Synchronized方法块中的原子执行），可见性（Synchronized方法块中的变量改变后都会刷新回主存），有序性（串行执行）。\nsynchronized是java同步关键字，可以使用它来同步方法或者代码块，它是通过存放在锁对象的对象头的markword中的信息来管理锁的，markword的内容如下：\n"),t("img",{attrs:{src:n(417),alt:"object head"}})]),r._v(" "),t("p",[r._v("通过上图可以看出，markword通过两位锁标记位以及一位偏向锁位定义了它的5种状态：")]),r._v(" "),t("ol",[t("li",[r._v("锁标记位（00）：对应轻量级锁状态")]),r._v(" "),t("li",[r._v("锁标记位（01）：\n"),t("ul",[t("li",[r._v("偏向锁标记位（0）：无锁状态")]),r._v(" "),t("li",[r._v("偏向锁标记位（1）：偏向锁状态")])])]),r._v(" "),t("li",[r._v("锁标记位（10）：重量级锁")]),r._v(" "),t("li",[r._v("锁标记位（11）：GC状态")])]),r._v(" "),t("h1",{attrs:{id:"锁升级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁升级"}},[r._v("#")]),r._v(" 锁升级")]),r._v(" "),t("p",[r._v("在jdk1.6以前，synchronized通过mutex锁实现，需要挂起当前线程，在内核态和用户态切换，比较耗时，所以是重量级锁。\n1.6开始对它进行了优化，于是有了锁升级过程。也就是无锁->偏向锁->轻量级锁->重量级锁。")]),r._v(" "),t("p",[r._v("大部分时候，被同步的方法或者代码块不会被多个线程同时访问，因此我们可以用乐观锁的思路，通过cas操作来标记，因此引入偏向锁、轻量级锁。")]),r._v(" "),t("ol",[t("li",[r._v("偏向锁\n当线程第一次访问同步代码时，判断对象头的标记，如果是无锁状态，则将mark word 改成偏向锁模式，同时使用cas操作将偏向锁的线程id改为当前线程id，如果cas操作成功，则执行同步代码，如果失败，说明当前有其他线程也在竞争，则需要将偏向锁升级到轻量级锁")]),r._v(" "),t("li",[r._v("轻量级锁\n即自旋锁。虚拟机首先在当前线程的栈帧中建立一个名为lock record的空间，用于存储锁对象目前的mark word拷贝，然后虚拟机采用cas操作将锁对象的mark word更新为指向lock record的指针，同时将锁标记位改为轻量级锁，成功则获得该锁，失败则说明有其他线程已经取得了该锁。如果有两个以上的线程争用这个锁，则锁必须膨胀为重量级锁。")]),r._v(" "),t("li",[r._v("重量级锁\n基于mutex实现，挂起线程。")])])])}),[],!1,null,null,null);t.default=o.exports}}]);