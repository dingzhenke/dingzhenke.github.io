(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{453:function(e,n,a){"use strict";a.r(n);var l=a(2),t=Object(l.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p"),n("div",{staticClass:"table-of-contents"},[n("ul",[n("li",[n("a",{attrs:{href:"#客户端连接"}},[e._v("客户端连接")])]),n("li",[n("a",{attrs:{href:"#二进制数据"}},[e._v("二进制数据")])])])]),e._v("\n在Netty源码分析（三）中我们已经了解了ChannelPipeline的机制，知道数据在服务器经过了ChannelPipeline拥有的一系列ChannelHandler的处理，那我们就来看看服务器时如何处理接收到的数据的。这里的数据有两种，一种是客户端连接，一种是普通的二进制数据。"),n("p"),e._v(" "),n("h2",{attrs:{id:"客户端连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#客户端连接"}},[e._v("#")]),e._v(" 客户端连接")]),e._v(" "),n("p",[e._v("我们先讲客户端连接，毕竟要先建立连接，才能发送数据。在Netty源码分析（二）中已经解释了处理连接的channel是NioServerSocketChannel，且最终执行pipeline.fireChannelRead(readBuf.get(i))方法。执行fireChannelRead的话，会依次调用其下的ChannelHandler的channelRead方法。\nNioServerSocketChannel初始化的时候添加了一个Handler--ServerBootstrapAcceptor。它的channelRead方法如下:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public void channelRead(ChannelHandlerContext ctx, Object msg) {\n    final Channel child = (Channel) msg;\n\n    child.pipeline().addLast(childHandler);\n\n    setChannelOptions(child, childOptions, logger);\n    setAttributes(child, childAttrs);\n\n    try {\n        childGroup.register(child).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    forceClose(child, future.cause());\n                }\n            }\n        });\n    } catch (Throwable t) {\n        forceClose(child, t);\n    }\n}\n")])])]),n("p",[e._v("该方法主要是做了两件事:")]),e._v(" "),n("ol",[n("li",[e._v("将childHandler添加到客户端连接的ChannelPipeline里。")]),e._v(" "),n("li",[e._v("将客户端连接注册到childGroup上。")])]),e._v(" "),n("p",[e._v("以下面代码为例:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workGroup)\n        .channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(final SocketChannel ch) throws Exception {\n\n            }\n        });\n")])])]),n("p",[e._v("childGroup就是workGroup，childHandler就是内部类ChannelInitializer。\n至此对客户端连接的处理就分析完毕。")]),e._v(" "),n("h2",{attrs:{id:"二进制数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二进制数据"}},[e._v("#")]),e._v(" 二进制数据")]),e._v(" "),n("p",[e._v("在我们的例子中，二级制数据的收发是通过NioSocketChannel来操作的。同Netty源码分析（二）中一样，NioSocketChannel也继承AbstractNioChannel，所以最后也调用AbstractNioChannel.NioUnsafe.read()方法，不同的是，NIOSocketChannel继承的是AbstractNioByteChannel，所以调用的AbstractNioByteChannel\n的unsafe的read方法:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Override\npublic final void read() {\n    ......\n    ByteBuf byteBuf = null;\n    boolean close = false;\n    try {\n        do {\n            byteBuf = allocHandle.allocate(allocator);\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() <= 0) {\n                // nothing was read. release the buffer.\n                byteBuf.release();\n                byteBuf = null;\n                close = allocHandle.lastBytesRead() < 0;\n                if (close) {\n                    // There is nothing left to read as we received an EOF.\n                    readPending = false;\n                }\n                break;\n            }\n\n            allocHandle.incMessagesRead(1);\n            readPending = false;\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf = null;\n        } while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (close) {\n            closeOnRead(pipeline);\n        }\n    } catch (Throwable t) {\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    } finally {\n        ......\n    }\n}\n")])])]),n("p",[e._v("这里主要就是读取二进制数据，然后通过pipeline.fireChannelRead(byteBuf)传递数据，后面的就是ChannelPipeline的处理逻辑了，前面已经说明过，就不再复述。")])])}),[],!1,null,null,null);n.default=t.exports}}]);